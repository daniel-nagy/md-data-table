'use strict';

angular.module('md.data.table')
  .decorator('$controller', controllerDecorator)
  .factory('$mdEditDialog', mdEditDialog)
  .directive('mdEditDialog', mdEditDialogDirective);

/*
 * A decorator for ng.$controller to optionally bind properties to the
 * controller before invoking the constructor. Stolen from the ngMock.
 *
 * https://docs.angularjs.org/api/ngMock/service/$controller
 */
function controllerDecorator($delegate) {
  return function (expression, locals, later, ident) {
    if (later && typeof later === 'object') {
      var create = $delegate(expression, locals, true, ident);
      angular.extend(create.instance, later);
      return create();
    }
    return $delegate(expression, locals, later, ident);
  };
}

controllerDecorator.$inject = ['$delegate'];

function mdEditDialogDirective($mdTheming) {
  return {
    restrict: 'E',
    link: function (scope, element) {
      $mdTheming(element);
    }
  };
}

mdEditDialogDirective.$inject = ['$mdTheming'];

function mdEditDialog($compile, $controller, $document, $mdUtil, $q, $rootScope, $templateCache, $templateRequest, $window) {
  /* jshint validthis: true */

  var ESCAPE = 27;

  var busy = false;
  var body = angular.element($document.prop('body'));

  /*
   * bindToController
   * controller
   * controllerAs
   * locals
   * resolve
   * scope
   * targetEvent
   * template
   * templateUrl
   */
  var defaultOptions = {
    clickOutsideToClose: true,
    disableScroll: true,
    escToClose: true,
    focusOnOpen: true
  };

  function build(template, options) {
    var scope = $rootScope.$new();
    var element = $compile(template)(scope);
    if (options.mdTheme) {
      scope.mdTheme = options.mdTheme;
    }
    var backdrop = $mdUtil.createBackdrop(scope, 'md-edit-dialog-backdrop');
    var controller;

    if (options.controller) {
      controller = getController(options, scope, {
        $element: element,
        $scope: scope
      });
    } else {
      angular.extend(scope, options.scope);
    }

    if (options.disableScroll) {
      disableScroll(element);
    }

    body.prepend(backdrop).append(element.addClass('md-whiteframe-1dp'));

    positionDialog(element, options.target);

    if (options.focusOnOpen) {
      focusOnOpen(element);
    }

    if (options.clickOutsideToClose) {
      backdrop.on('click', function () {
        element.remove();
      });
    }

    if (options.escToClose) {
      escToClose(element);
    }

    element.on('$destroy', function () {
      busy = false;
      backdrop.remove();
    });

    return controller;
  }

  function disableScroll(element) {
    var restoreScroll = $mdUtil.disableScrollAround(element, body);

    element.on('$destroy', function () {
      restoreScroll();
    });
  }

  function getController(options, scope, inject) {
    if (!options.controller) {
      return;
    }

    if (options.resolve) {
      angular.extend(inject, options.resolve);
    }

    if (options.locals) {
      angular.extend(inject, options.locals);
    }

    if (options.controllerAs) {
      scope[options.controllerAs] = {};

      if (options.bindToController) {
        angular.extend(scope[options.controllerAs], options.scope);
      } else {
        angular.extend(scope, options.scope);
      }
    } else {
      angular.extend(scope, options.scope);
    }

    if (options.bindToController) {
      return $controller(options.controller, inject, scope[options.controllerAs]);
    } else {
      return $controller(options.controller, inject);
    }
  }

  function getTemplate(options) {
    return $q(function (resolve, reject) {
      var template = options.template;

      function illegalType(type) {
        reject('Unexpected template value. Expected a string; received a ' + type + '.');
      }

      if (template) {
        return angular.isString(template) ? resolve(template) : illegalType(typeof template);
      }

      if (options.templateUrl) {
        template = $templateCache.get(options.templateUrl);

        if (template) {
          return resolve(template);
        }

        var success = function (template) {
          return resolve(template);
        };

        var error = function () {
          return reject('Error retrieving template from URL.');
        };

        return $templateRequest(options.templateUrl).then(success, error);
      }

      reject('Template not provided.');
    });
  }

  function logError(error) {
    busy = false;
    console.error(error);
  }

  function escToClose(element) {
    var keyup = function (event) {
      if (event.keyCode === ESCAPE) {
        element.remove();
      }
    };

    body.on('keyup', keyup);

    element.on('$destroy', function () {
      body.off('keyup', keyup);
    });
  }

  function focusOnOpen(element) {
    $mdUtil.nextTick(function () {
      var autofocus = $mdUtil.findFocusTarget(element);

      if (autofocus) {
        autofocus.focus();
      }
    }, false);
  }

  function positionDialog(element, target) {
    var table = angular.element(target).controller('mdCell').getTable();

    var getHeight = function () {
      return element.prop('clientHeight');
    };

    var getSize = function () {
      return {
        width: getWidth(),
        height: getHeight()
      };
    };

    var getTableBounds = function () {
      var parent = table.parent();

      if (parent.prop('tagName') === 'MD-TABLE-CONTAINER') {
        return parent[0].getBoundingClientRect();
      } else {
        return table[0].getBoundingClientRect();
      }
    };

    var getWidth = function () {
      return element.prop('clientWidth');
    };

    var reposition = function () {
      var size = getSize();
      var cellBounds = target.getBoundingClientRect();
      var tableBounds = getTableBounds();

      if (size.width > tableBounds.right - cellBounds.left) {
        element.css('left', tableBounds.right - size.width + 'px');
      } else {
        element.css('left', cellBounds.left + 'px');
      }

      if (size.height > tableBounds.bottom - cellBounds.top) {
        element.css('top', tableBounds.bottom - size.height + 'px');
      } else {
        element.css('top', cellBounds.top + 1 + 'px');
      }

      element.css('minWidth', cellBounds.width + 'px');
    };

    var watchWidth = $rootScope.$watch(getWidth, reposition);
    var watchHeight = $rootScope.$watch(getHeight, reposition);

    $window.addEventListener('resize', reposition);

    element.on('$destroy', function () {
      watchWidth();
      watchHeight();

      $window.removeEventListener('resize', reposition);
    });
  }

  function preset(size, options) {

    function getAttrs() {
      var attrs = 'type="' + (options.type || 'text') + '"';

      for (var attr in options.validators) {
        attrs += ' ' + attr + '="' + options.validators[attr] + '"';
      }

      return attrs;
    }

    return {
      controller: ['$element', '$q', 'save', '$scope', function ($element, $q, save, $scope) {
        function update() {
          if ($scope.editDialog.$invalid) {
            return $q.reject();
          }

          if (angular.isFunction(save)) {
            return $q.when(save($scope.editDialog.input));
          }

          return $q.resolve();
        }

        this.dismiss = function () {
          $element.remove();
        };

        this.getInput = function () {
          return $scope.editDialog.input;
        };

        $scope.dismiss = this.dismiss;

        $scope.submit = function () {
          update().then(function () {
            $scope.dismiss();
          });
        };
      }],
      locals: {
        save: options.save
      },
      scope: {
        cancel: options.cancel || 'Cancel',
        messages: options.messages,
        model: options.modelValue,
        ok: options.ok || 'Save',
        placeholder: options.placeholder,
        title: options.title,
        size: size
      },
      template: '<md-edit-dialog md-theme="{{mdTheme}}">' +
      '<div layout="column" class="md-content">' +
      '<div ng-if="size === \'large\'" class="md-title">{{title || \'Edit\'}}</div>' +
      '<form name="editDialog" layout="column" ng-submit="submit(model)">' +
      '<md-input-container md-no-float>' +
      '<input name="input" ng-model="model" md-autofocus placeholder="{{placeholder}} "' + getAttrs() + '>' +
      '<div ng-messages="editDialog.input.$error">' +
      '<div ng-repeat="(key, message) in messages" ng-message="{{key}}">{{message}}</div>' +
      '</div>' +
      '</md-input-container>' +
      '</form>' +
      '</div>' +
      '<div ng-if="size === \'large\'" layout="row" layout-align="end" class="md-actions">' +
      '<md-button class="md-primary" ng-click="dismiss()">{{cancel}}</md-button>' +
      '<md-button class="md-primary" ng-click="submit()">{{ok}}</md-button>' +
      '</div>' +
      '</md-edit-dialog>'
    };
  }

  this.show = function (options) {
    if (busy) {
      return $q.reject();
    }

    busy = true;
    options = angular.extend({}, defaultOptions, options);

    if (!options.targetEvent) {
      return logError('options.targetEvent is required to align the dialog with the table cell.');
    }

    if (!options.targetEvent.currentTarget.classList.contains('md-cell')) {
      return logError('The event target must be a table cell.');
    }

    if (options.bindToController && !options.controllerAs) {
      return logError('You must define options.controllerAs when options.bindToController is true.');
    }

    options.target = options.targetEvent.currentTarget;

    var promise = getTemplate(options);
    var promises = [promise];

    for (var prop in options.resolve) {
      promise = options.resolve[prop];
      promises.push($q.when(angular.isFunction(promise) ? promise() : promise));
    }

    promise = $q.all(promises);

    promise['catch'](logError);

    return promise.then(function (results) {
      var template = results.shift();

      for (var prop in options.resolve) {
        options.resolve[prop] = results.shift();
      }

      return build(template, options);
    });
  };

  this.small = function (options) {
    return this.show(angular.extend({}, options, preset('small', options)));
  }.bind(this);

  this.large = function (options) {
    return this.show(angular.extend({}, options, preset('large', options)));
  }.bind(this);

  return this;
}

mdEditDialog.$inject = ['$compile', '$controller', '$document', '$mdUtil', '$q', '$rootScope', '$templateCache', '$templateRequest', '$window'];
